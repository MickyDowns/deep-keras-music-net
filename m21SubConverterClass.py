# -*- coding: utf-8 -*-
#-------------------------------------------------------------------------------
# Name:         converter/__init__.py
# Purpose:      Specific subconverters for formats music21 should handle
#
# Authors:      Michael Scott Cuthbert
#               Christopher Ariza
#
# Copyright:    Copyright Â© 2009-2015 Michael Scott Cuthbert and the music21 Project
# License:      LGPL or BSD, see license.txt
#-------------------------------------------------------------------------------
'''
    Subconverters parse or display a single format.
    Each subconverter should inherit from the base SubConverter object and have at least a
    parseData method that sets self.stream.
'''
#-------------------------------------------------------------------------------
# Converters are associated classes; they are not subclasses, but most define a pareData() method,
# a parseFile() method, and a .stream attribute or property.
import io
import os
import sys

from music21.ext import six
from music21 import common
from music21 import defaults
from music21 import stream
from music21 import exceptions21

from music21 import environment
_MOD = 'converter/subConverters.py'
environLocal = environment.Environment(_MOD)


class SubConverterException(exceptions21.Music21Exception):
    pass

class SubConverterFileIOException(SubConverterException):
    pass

class SubConverter(object):
    '''
        Class wrapper for parsing data or outputting data.
        
        All other Converter types should inherit from this and
        have ways of dealing with various data formats.
        
        Attributes that should be set::
        
        readBinary = True or False (default False)
        registerFormats = tuple of formats that can be handled; eg: ('musicxml',)
        registerShowFormats = tuple of format calls that can be handled in .show() and .write()
        registerInputExtensions = tuple of input extensions that should be handled in converter
        registerOutputExtensions = tuple of output extensions that can be written. Order matters:
        the first will be used in calls to .write()
        canBePickled = True or False (default True; does not do anything yet)
        codecWrite = True or False (default False) if encodings need to be used to write
        stringEncoding = string (default 'utf-8'). If codecWrite is True, this specifies what
        encoding to use
    '''
    readBinary = False
    canBePickled = True
    registerFormats = ()
    registerShowFormats = ()
    registerInputExtensions = ()
    registerOutputExtensions = ()
    registerOutputSubformatExtensions = {}
    launchKey = None
    
    codecWrite = False
    stringEncoding='utf-8'
    
    def __init__(self, **keywords):
        self._stream = stream.Score()
        self.keywords = keywords
    
    def parseData(self, dataString, number=None):
        '''
            Called when a string (or binary) data is encountered.
            
            This method MUST be implemented to do anything in parsing.
        '''
        return self.stream
    
    def parseFile(self, filePath, number=None):
        '''
            Called when a file is encountered. If all that needs to be done is
            loading the file and putting the data into parseData then there is no need
            to do anything except set self.readBinary (True|False).
        '''
        if self.readBinary is False:
            with open(filePath) as f:
                dataStream = f.read()
        else:
            with open(filePath, 'rb') as f:
                dataStream = f.read()
        self.parseData(dataStream, number)
        return self.stream
    
    def _getStream(self):
        return self._stream
    
    def _setStream(self, newStream):
        self._stream = newStream
    
    stream = property(_getStream, _setStream, doc='''
        Returns or sets the stream in the converter.  Must be defined for subconverter to work.
        ''')
    
    def checkShowAbility(self, **keywords):
        '''
            return bool on whether the *system* is
            equipped to show in this format.
            
            Default True. Might be False if, say
            a Lilypond converter is used and Lilypond
            is not installed.
        '''
        return True
    
    def launch(self, filePath, fmt=None, options='', app=None, launchKey=None):
        '''
            Opens the appropriate viewer for the file generated by .write()
            
            app is the path to an application to launch.  Specify it and/or a launchKey
            launchKey is the specific key in .music21rc (such as graphicsPath), etc.
            to search for the application.  If it's not specified then there might be
            a default one for the converter in self.launchKey.  If it can't find it
            there then environLocal.formatToApp(fmt) will be used.
        '''
        if fmt is None and self.registerShowFormats:
            fmt = self.registerShowFormats[0]
        if app is None:
            if launchKey is not None:
                app = environLocal[launchKey]
            elif self.launchKey is not None:
                launchKey = self.launchKey
                app = environLocal[launchKey]
            else:
                launchKey = environLocal.formatToKey(fmt)
                app = environLocal.formatToApp(fmt)
        
        platform = common.getPlatform()
        if app is None:
            if platform == 'win':
                # no need to specify application here:
                # windows starts the program based on the file extension
                cmd = 'start %s' % (filePath)
            elif platform == 'darwin':
                cmd = 'open %s %s' % (options, filePath)
            else:
                raise SubConverterException("Cannot find a valid application path for format {}. "
                                            "Specify this in your Environment by calling "
                                            "environment.set({!r}, '/path/to/application')".format(fmt, launchKey))
        elif platform == 'win':  # note extra set of quotes!
            cmd = '""%s" %s "%s""' % (app, options, filePath)
        elif platform == 'darwin':
            cmd = 'open -a"%s" %s %s' % (app, options, filePath)
        elif platform == 'nix':
            cmd = '%s %s %s' % (app, options, filePath)
        os.system(cmd)

    def show(self, obj, fmt, app=None, subformats=None, **keywords):
        returnedFilePath = self.write(obj, fmt, subformats=subformats, **keywords)
        self.launch(returnedFilePath, fmt=fmt, app=app)

    def getExtensionForSubformats(self, subformats=None):
        '''
            Given a default format or subformats, give the file extension it should have:
            
            >>> c = converter.subConverters.ConverterLilypond()
            
            This is currently basically completely unused!!!!
        '''
        exts = self.registerOutputExtensions
        if len(exts) == 0:
            raise SubConverterException(
                                        "This subconverter cannot show or write: " +
                                        "no output extensions are registered for it")
        # start by trying the first one.
        ext = exts[0]
        if self.registerOutputSubformatExtensions and subformats is not None:
            joinedSubformats = '.'.join(subformats)
            if joinedSubformats in self.registerOutputSubformatExtensions:
                ext = self.registerOutputSubformatExtensions[joinedSubformats]
        return "." + ext

    def getTemporaryFile(self, subformats=None):
        '''
        This is never called with subformats and should probably be deleted!
        
        >>> c = corpus.parse('bwv66.6')
        >>> lpConverter = converter.subConverters.ConverterLilypond()
        >>> tf = lpConverter.getTemporaryFile(subformats=['png'])
        >>> tf.endswith('.png')
        True
        '''
        ext = self.getExtensionForSubformats(subformats)
        fp = environLocal.getTempFile(ext)
        return fp

    def write(self, obj, fmt, fp=None, subformats=None, **keywords):
        dataStr = repr(obj)
        self.writeDataStream(fp, dataStr)
        return fp
    
    def writeDataStream(self, fp, dataStr):
        if fp is None:
            fp = self.getTemporaryFile()
        
        if self.readBinary is False:
            writeFlags = 'w'
        else:
            writeFlags = 'wb'
        
        if self.codecWrite is False:
            if hasattr(fp, 'write'):
                # is a filelike object
                f = fp
            else:
                fp = common.cleanpath(fp)
                f = open(fp, writeFlags)
            
            try:
                if six.PY3 and isinstance(dataStr, bytes):
                    f.write(dataStr.decode('utf-8'))
                
                else:
                    f.write(dataStr)
            except UnicodeEncodeError:
                f.close()
                f = io.open(fp, mode=writeFlags, encoding=self.stringEncoding)
                f.write(dataStr)
                f.close()
            
            except TypeError as te:
                raise SubConverterException("Could not convert %r : %r" % (dataStr, te))
        else:
            if hasattr(fp, 'write'): 
                # is a filelike object
                f = fp
            else:
                f = io.open(fp, mode=writeFlags, encoding=self.stringEncoding)
            f.write(dataStr)
            f.close()
        return fp